<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://osujin.github.io/"/>
  <updated>2018-04-04T05:56:15.855Z</updated>
  <id>https://osujin.github.io/</id>
  
  <author>
    <name>sujin Oh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mybatis foreach를 이용해 insert batch 처리하기</title>
    <link href="https://osujin.github.io/2018/01/16/mybatis-foreach%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-insert-batch-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0/"/>
    <id>https://osujin.github.io/2018/01/16/mybatis-foreach를-이용해-insert-batch-처리하기/</id>
    <published>2018-01-16T08:46:22.000Z</published>
    <updated>2018-04-04T05:56:15.855Z</updated>
    
    <content type="html"><![CDATA[<p>30만정도 되는 데이터를 insert 해야하는데 for문을 이용한 단순 반복문으로 실행하니 insert가 안된다.</p><p>그래서 Mapper xml 에서 <foreach> 테그를 이용하여 대량의 데이터를 insert 하는 방법을 적어둔다.</foreach></p><p><strong>java code</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line"> List&lt;table&gt;</span><br><span class="line">  tableList;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              sqlSession = getSqlSessionFactory().openSession(<span class="keyword">false</span>);</span><br><span class="line">              Mapper table = sqlSession.getMapper(Mapper.class);</span><br><span class="line">              Mapper.insert(tableList);<span class="comment">//List를 넘겨준다.</span></span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              sqlSession.commit();</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>위와 같이 List를 Mapper로 전달해주고 xml에서 활용하며된다.</p><p><strong>Mapper XML</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">"insert"</span> parameterType=“com.example.table<span class="string">"&gt;</span></span><br><span class="line"><span class="string">      insert into test (id, name, age)</span></span><br><span class="line"><span class="string">    VALUES</span></span><br><span class="line"><span class="string">    &lt;foreach item="</span>table<span class="string">" index="</span>index<span class="string">" collection="</span>list<span class="string">"  separator="</span>,<span class="string">"&gt;</span></span><br><span class="line"><span class="string">     (</span></span><br><span class="line"><span class="string">      #&#123;table.emsid&#125;,</span></span><br><span class="line"><span class="string">      #&#123;table.id&#125;,</span></span><br><span class="line"><span class="string">      #&#123;table.name&#125;,</span></span><br><span class="line"><span class="string">      #&#123;table.age&#125;</span></span><br><span class="line"><span class="string">     )</span></span><br><span class="line"><span class="string">    &lt;/foreach&gt;</span></span><br><span class="line"><span class="string">  &lt;/insert&gt;</span></span><br></pre></td></tr></table></figure><p>foreach 태그에서 collection 컬럼은 넘겨진 파라미터가 List 형태이므로 list라고 적어주면 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;30만정도 되는 데이터를 insert 해야하는데 for문을 이용한 단순 반복문으로 실행하니 insert가 안된다.&lt;/p&gt;
&lt;p&gt;그래서 Mapper xml 에서 &lt;foreach&gt; 테그를 이용하여 대량의 데이터를 insert 하는 방법을 적어둔다.&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://osujin.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java ThreadPool Example</title>
    <link href="https://osujin.github.io/2017/11/13/java-threadpool-example/"/>
    <id>https://osujin.github.io/2017/11/13/java-threadpool-example/</id>
    <published>2017-11-13T00:22:06.000Z</published>
    <updated>2018-04-04T05:55:11.275Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Future future = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ExecutorService 인터페이스 구현객체 Executors 정적메서드를 통해 최대 스레드 개수가 2인 스레드 풀 생성</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//스레드에게 시킬 작업 내용</span></span><br><span class="line">                    ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">int</span> poolSize = threadPoolExecutor.getPoolSize();<span class="comment">//스레드 풀 사이즈 얻기</span></span><br><span class="line">                    String threadName = Thread.currentThread().getName();<span class="comment">//스레드 풀에 있는 해당 스레드 이름 얻기</span></span><br><span class="line">                    System.out.println(<span class="string">"[총 스레드 개수:"</span> + poolSize + <span class="string">"] 작업 스레드 이름: "</span> + threadName);</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">//일부로 예외 발생 시킴</span></span><br><span class="line"><span class="comment">//                    int value = Integer.parseInt("예외");</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> Date().toString());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//스레드풀에게 작업 처리 요청</span></span><br><span class="line"><span class="comment">//            executorService.execute(runnable);</span></span><br><span class="line">          future = executorService.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                future.get();</span><br><span class="line">                System.out.println(<span class="string">"[작업 처리 완료]"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//스레드풀 종료</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"Finish"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Java" scheme="https://osujin.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>spring @Value Annotation 사용법</title>
    <link href="https://osujin.github.io/2017/09/20/spring-@Value-Annotation-%EC%82%AC%EC%9A%A9%EB%B2%95/"/>
    <id>https://osujin.github.io/2017/09/20/spring-@Value-Annotation-사용법/</id>
    <published>2017-09-20T02:21:32.000Z</published>
    <updated>2018-04-04T05:54:35.119Z</updated>
    
    <content type="html"><![CDATA[<p>spring을 이용하여 @Value Annotation 사용할때 properties 파일과 mapping 시키는데 삽질한 내용이다.</p><p>SpringContext.xml 에 아래와 같은 내용 properties를 만들어주고 context:component-scan 또한 선언해주어야 @Value Annotation 이 선언된 class 에서 properties를 참조하여 사용할수 있다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">"prop"</span> <span class="attr">location</span>=<span class="string">“classpath:sample.properties</span>" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">“com.spring.test</span>" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">properties-ref</span>=<span class="string">"prop"</span>  /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;spring을 이용하여 @Value Annotation 사용할때 properties 파일과 mapping 시키는데 삽질한 내용이다.&lt;/p&gt;
&lt;p&gt;SpringContext.xml 에 아래와 같은 내용 properties를 만들어주고 context:
      
    
    </summary>
    
      <category term="Java" scheme="https://osujin.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>spring-boot application.yml column mapping 사용 예제</title>
    <link href="https://osujin.github.io/2017/09/20/spring-boot-application.yml-column-mapping-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%A0%9C/"/>
    <id>https://osujin.github.io/2017/09/20/spring-boot-application.yml-column-mapping-사용-예제/</id>
    <published>2017-09-20T02:14:45.000Z</published>
    <updated>2018-04-04T05:58:56.858Z</updated>
    
    <content type="html"><![CDATA[<p>spring-boot 에서 properties 파일을 사용하지 않고 yml 이라는 파일을 사용해 설정값등을 명시해주는데 이에대한 간략한 사용방법이다.</p><p>일단 resource 하위에 application.yml 파일을 만들고 아래와 같이 내용을 채워넣는다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:postgresql://1.1.1.1:5432/abc</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">test123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">settings:</span></span><br><span class="line"><span class="attr">  user:</span></span><br><span class="line"><span class="attr">    id:</span> <span class="string">osujin12</span></span><br><span class="line"><span class="attr">    pw:</span> <span class="string">aaaa</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    ip:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>그리고 위 내용을 매핑시킬 context class 를 하나 선언하고 Annotation을 선언해주면 자동으로 매핑이 되는데 몇가지 방법이 존재한다.</p><ol><li><p>@Value 를 이용하여 1:1 로 mapping 하는방법</p><ul><li>@Configuration , @EnableConfigurationProperties</li></ul></li></ol><p>위두개의 Annotation을 선언해주면 자동으로 yml 파일을(application.yml 파일은 따로 설정없이 자동으로 인식한다. 이름이 여러개의 yml 파일도 적용할수 있는데 이런경우 추가 설정이 필요하다.) load 한다. 그리고 선언된 변수에 yml 컬럼 명을 명시해주면 값이 셋팅된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;settings.server.ip&#125;&quot;)</span><br><span class="line">   String ip;</span><br></pre></td></tr></table></figure><ol><li><p>객체에 yml을 mapping 하는 방법</p><ul><li>@ConfigurationProperties(prefix = “settings”)</li></ul></li></ol><p>1번의 Annotation과 함께 위에 선언된 ConfigurationProperties Annotation을 사용하면 settings 하위에 있는 user,server 항목을 객체로 변환하여 자동으로 maaping 할수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String id;</span><br><span class="line">    String pw;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pw;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPw</span><span class="params">(String pw)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pw = pw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 User 클래스를 선언한뒤 Context에 User 를 선언만 해주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"settings"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;settings.server.ip&#125;"</span>)</span><br><span class="line">    String ip;</span><br><span class="line"> </span><br><span class="line">    User user; </span><br><span class="line"><span class="comment">//getter , setter 생략 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Context class 결과</strong></p><p><img src="/image/2017/09/스크린샷-2017-09-20-오전-11.13.25.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;spring-boot 에서 properties 파일을 사용하지 않고 yml 이라는 파일을 사용해 설정값등을 명시해주는데 이에대한 간략한 사용방법이다.&lt;/p&gt;
&lt;p&gt;일단 resource 하위에 application.yml 파일을 만들고 아래와 같이
      
    
    </summary>
    
      <category term="Java" scheme="https://osujin.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>spring-boot mybatis 연동 주의점</title>
    <link href="https://osujin.github.io/2017/09/07/spring-boot-mybatis-%EC%97%B0%EB%8F%99-%EC%A3%BC%EC%9D%98%EC%A0%90/"/>
    <id>https://osujin.github.io/2017/09/07/spring-boot-mybatis-연동-주의점/</id>
    <published>2017-09-07T06:09:53.000Z</published>
    <updated>2018-04-04T06:01:25.484Z</updated>
    
    <content type="html"><![CDATA[<p>spring boot 를 이용하여 DB를 연동할때 자동으로 DB 커넥션을 생성하는 방법을 사용하는데</p><p>yml 파일에 db 연결 정보를 아래 규격에 맞춰야 한다.</p><p>spring 이라는 element 아래 datasource element를 생성하고 그 하위에 url,username,password 를 입력해주면 자동으로 불러와 셋팅을 해준다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:postgresql://58.181.37.137:5432/tsdn</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">tsdn</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123</span><span class="string">!@#</span></span><br></pre></td></tr></table></figure><p>yml 파일을 설정한 뒤에는 Mapperscan annotation 을 선언해줘야 하는데 sping에 의존성이 주입된 class 어디서나 선언해도 자동으로 불러들이는 것같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan</span>(“com.java.test.pkg)</span><br></pre></td></tr></table></figure><p>하지만 명시적으로 확인해주기 위해 dao 관련 class에서 선언을 해주는게 좋을것 같다.</p><p>MapperScan을 선언해주지 않으면 sql connection이 자동으로 생성되지 않는다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;spring boot 를 이용하여 DB를 연동할때 자동으로 DB 커넥션을 생성하는 방법을 사용하는데&lt;/p&gt;
&lt;p&gt;yml 파일에 db 연결 정보를 아래 규격에 맞춰야 한다.&lt;/p&gt;
&lt;p&gt;spring 이라는 element 아래 datasource e
      
    
    </summary>
    
      <category term="Java" scheme="https://osujin.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Facebook Chatbot 과 Redis 활용</title>
    <link href="https://osujin.github.io/2017/08/28/Facebook-Chatbot%EA%B3%BC-Redis-%ED%99%9C%EC%9A%A9/"/>
    <id>https://osujin.github.io/2017/08/28/Facebook-Chatbot과-Redis-활용/</id>
    <published>2017-08-28T05:17:07.000Z</published>
    <updated>2018-04-04T02:14:12.749Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js로 Facebook Chatboot 서비스를 구축하며 다른 서비스들과 연동을 해야하는데 데이터 저장을 위한 DB로 Redis를 활용해보았다.</p><p>redis는 NoSQL DB로 key-value 구조로 데이터를 저장하는 구조라서 복잡한 서비스에 대한 데이터를 수용하기엔 적절치 않지만 NoSQL DB도 써볼겸 적용해보았다.</p><p>일단 Facebook chatbot에서 사용하는 아이디와 Facebook email 정보를 저장하고 Facebook Chatboot 고유 id 와 email 주소를 매핑 시켜줄 저장소를 DB0 에 저장했다. ( Redis는 기본적으로 16개의 독립적인 DB 구역을 사용할수 있다)</p><p>이는 최초 chatbot을 통해 내가 구현한 서비스와 facebook 계정을 연동 해주기 위한 DB로 활용되었다.</p><p><img src="/image/2017/08/스크린샷-2017-08-28-오전-11.17.52.png" alt=""></p><p>위 그림처럼 account linking 라고 메시지를 보내면 facebook과 MemoryCalendar 서비스를 연동시킬수 있는 url이 넘어오고 이를 클릭하고 facebook login 버튼을 눌러 연동을 하면 MemoryCalendar에서 해당 유저의 정보를 확인 할 수 있다.</p><p>facebook 연동 과정과 Redis에 저장되는 데이터를 함께 확인하면 아래와 같다.</p><ol><li>account linking 매시지 전송 : redis - user 고유 ID를 key값으로하고 랜덤하게 생성된 임이의 문자열을 value로 하여 encryptChatID를 key값으로 하는 저장소에 저장하였다.</li></ol><p><img src="/image/2017/08/스크린샷-2017-08-28-오후-2.01.58.png" alt=""></p><ol><li>url클릭 후 facebook login 버튼 클릭 : facebook login 버튼을 눌러 연동을 하면 개인정보 접근이 가능하고 email 주소와 chat Id 를 맵핑 시켜 idMapper 를 key 로 하는 저장소에 저장하였다.</li></ol><p><img src="/image/2017/08/스크린샷-2017-08-28-오후-2.05.49.png" alt=""></p><p>이와 같은 방법으로 email 주소를 통해 chatId 를 찾을 수 있도록 하였고 chatId 가 외부로 노출되는 경우를 방지하기 위해 임시 key 값을 발급하는 형태로 구조를 잡았다.</p><p>앞으로 서비스에서 사용될 개별 유저 셋팅에 대한 정보도 email 이나 chatid를 이용하여 설계하여 개발하면 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Node.js로 Facebook Chatboot 서비스를 구축하며 다른 서비스들과 연동을 해야하는데 데이터 저장을 위한 DB로 Redis를 활용해보았다.&lt;/p&gt;
&lt;p&gt;redis는 NoSQL DB로 key-value 구조로 데이터를 저장하는 구조라
      
    
    </summary>
    
      <category term="IoT" scheme="https://osujin.github.io/categories/IoT/"/>
    
    
  </entry>
  
  <entry>
    <title>gitlab 관리자 비번 초기화 및 project limit 늘리기</title>
    <link href="https://osujin.github.io/2017/07/18/gitlab-%EA%B4%80%EB%A6%AC%EC%9E%90-%EB%B9%84%EB%B2%88-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%B0%8F-project-limit-%EB%8A%98%EB%A6%AC%EA%B8%B0/"/>
    <id>https://osujin.github.io/2017/07/18/gitlab-관리자-비번-초기화-및-project-limit-늘리기/</id>
    <published>2017-07-18T04:46:53.000Z</published>
    <updated>2018-04-04T06:11:34.885Z</updated>
    
    <content type="html"><![CDATA[<p>gitlab 관리자 비번 설정</p><ol><li>gitlab 설치 계정으로 로그인</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$gitlab-rails console production</span><br><span class="line"></span><br><span class="line">irb(main):002:0* user = User.where(id: 1).first</span><br><span class="line"></span><br><span class="line">irb(main):003:0&gt; user.password = ‘secret_pass’</span><br><span class="line"></span><br><span class="line">irb(main):004:0&gt; user.password_confirmation = ‘secret_pass’</span><br><span class="line"></span><br><span class="line">irb(main):005:0&gt; user.save!</span><br></pre></td></tr></table></figure><ol><li>project limit 변경 gitlab 기본 설정시 프로젝트 개수 제한이 10개로 설정되어있는데 이미 계정을 만들고 나서 관리자 계정으로 이 설정을 변경해도 기존에 만들어진 계정에는 적용이 안되었다. 이럴때는 수동으로 값을 변경해주면 된다.</li></ol><ul><li>gitlab 설치 계정으로 로그인</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gitlab-rails console production</span><br><span class="line"></span><br><span class="line">irb(main):002:0* user = User.where(id: [변경하려는 계정의 숫자]).first</span><br><span class="line"></span><br><span class="line">irb(main):003:0&gt; user.projects_limit = 99999</span><br><span class="line"></span><br><span class="line">irb(main):005:0&gt; user.save!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;gitlab 관리자 비번 설정&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;gitlab 설치 계정으로 로그인&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
      <category term="기타" scheme="https://osujin.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Facebook Messenger와 Node js 를 이용하여 아두이노 조작하기</title>
    <link href="https://osujin.github.io/2017/07/05/Facebook-Messenger%EC%99%80-Node.js%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%95%84%EB%91%90%EC%9D%B4%EB%85%B8-%EC%A1%B0%EC%9E%91%ED%95%98%EA%B8%B0/"/>
    <id>https://osujin.github.io/2017/07/05/Facebook-Messenger와-Node.js를-이용하여-아두이노-조작하기/</id>
    <published>2017-07-05T07:05:23.000Z</published>
    <updated>2018-04-04T06:04:47.767Z</updated>
    
    <content type="html"><![CDATA[<p>페이스북 메신저에서 제공하는 챗봇(chat-bot) 기능을 통해 아두이노와 같은 장비에 메시지를 주고 받는 기능을 개발해보기로 했다.</p><p>가장 먼저 <a href="https://developers.facebook.com/docs/messenger-platform/guides/quick-start" target="_blank" rel="noopener">페이스북 메신저 SDK</a> 사이트를 참고하여 챗봇이 가능한 환경을 셋팅해주고 Node js 로 서비스가 가능한 소스를 개인서버에서 동작시켜줘야한다.</p><p>챗봇 서비스를 정상적으로 실행하기 위해서는 필히 https 를 통해 서비스를 제공하도록 제한하고 있는것 같다.</p><p>그런데 <a href="https://github.com/fbsamples/messenger-platform-samples" target="_blank" rel="noopener">github</a>에 올라온 소스는 https가 완전히 적용된 소스가 아니라 추가적인 수정이 필요하다.</p><p>그리고 app.js 파일에 모든 소스가 있기때문에 이를 분리해줘야 한다. 분리작업은 express router 기능을 이용하면 손쉽게 분리가 된다.</p><p>분리할때 url 경로를 기준으로 분리했는데</p><ol><li>/authorize</li><li>/webhook</li></ol><p>이렇게 두개의 router 를 만들어 분리를 했다.</p><p>url을 분리한뒤에는 TOKEN 관련 상수들도 추가해주어야 페이스북 메신저에서 보낸 메시지가 제대로 날라오게 된다.</p><p>github에 올라온 소스는 app.js 에서 Listener 까지 띄워주지만 나는 Express 를 이용했기 때문에 www 라는 파일에서 Listener를 띄워줘야한다.</p><p>여기서 한가지 큰 문제가 있었다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[FB messenger] &lt;--https--&gt; [개인서버] &lt;--websocket--&gt; [아두이노]</span><br></pre></td></tr></table></figure><p>이렇게 서로 통신프로토콜을 정하였는데 websocket 과 https Listener 둘다 같은 port로 동작하도록 구현을 해야만 했다.</p><p>websocket 도 https 와 마찬가지로 router를 이용하여 서비스 별로 분리를 하려고 <a href="https://www.npmjs.com/package/express-ws-routes" target="_blank" rel="noopener">express-ws-routes</a> 모듈을 이용하여 websocket을 구현했다.</p><p>그런데 이 모듈은 WebSocket Security 를 지원하도록 만들어진건 아니라 일부분 수정이 필요했다.</p><p>일단 www 파일에서 Listener 를 띄우는 부분을 살펴보자</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    key: fs.readFileSync(<span class="string">'./keys/privkey.pem'</span>),</span><br><span class="line">    ca : fs.readFileSync(<span class="string">'./keys/chain.pem'</span>),</span><br><span class="line">    cert: fs.readFileSync(<span class="string">'./keys/cert.pem'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(options,app,<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Websocket listening on port 3000...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위소스에서 app.listen으로 넘겨지는 파라미터가 options,app,3000 총 3개인데 original source 에서는 포트 번호만 넘겨주고 끝이었다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">options</span> <span class="string">:</span> <span class="string">인증서</span> <span class="string">파일</span></span><br><span class="line"><span class="string">app</span> <span class="string">:</span> <span class="string">https</span> <span class="string">requestListener(router)</span></span><br><span class="line"><span class="number">3000</span> <span class="string">:</span> <span class="string">port</span> <span class="string">번호</span></span><br></pre></td></tr></table></figure><p>넘겨지는 파라미터는 위와 같은데 인증서 파일과 https requestListener를 동작할 수 있도록 추가적인 파라미터를 넘겨줘야 했고 이에 맞게 express-ws-routes 소스도 약간의 수정이 필요했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> app = exports.extendExpress(options)();</span><br><span class="line"></span><br><span class="line">    app.listen = <span class="function"><span class="keyword">function</span>(<span class="params">sslOption,requestListener,port</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> server = https.createServer(sslOption,requestListener);</span><br><span class="line">        server.listen(port)</span><br><span class="line">        server.wsServer = exports.createWebSocketServer(server, app, options);</span><br><span class="line">        <span class="keyword">return</span> server.listen.apply(server);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>위 소스가 수정된 소스인데 sslOption,requestListener,port 3개의 파라미터를 받아 https listener를 띄웠고 https 를 이용하여 websocket도 띄웠기 때문에 WebSocket Security 로 서비스가 올라갔다.</p><p>websocket 의 router 기능은 express-ws-routes 모듈내에서 지원해주는 기능이기 때문에 별도록 신경 쓸것은 없다.</p><p>여기 까지 했으면 일단 전체적인 틀은 잡은것이라고 생각한다.</p><p>마지막으로 확인해봐야 할것이 facebook messenger 와 통신과 아두이노와 통신이 되는지 확인해보는것인데 facebook messenger 에서 메시지를 날리면 몇몇 단어를 제외하곤 전부 echo를 하게 되어있다. 제대로 echo가 되는지 확인을 해보면 되고 websocket 통신은 간단한 websocket client를 만들어 접속해보고 접속이 잘되면 문제가 없는것이다.</p><p>마지막으로 여러대의 아두이노 들을 관리하기 위해 socket을 별도로 관리 해주어야 하는데 <a href="https://simplapi.wordpress.com/2012/05/14/node-js-singleton-structure/" target="_blank" rel="noopener">Node.JS Singleton structure</a> 이곳에 있는 소스를 참고하여 singleton 객체를 하나 만들어 socket을 저장하고 fb 메신저에서 특정 단어가 들어가면 singleton 객체에 저장된 소켓리스트에서 해당하는 아두이노를 찾아 메시지를 보내는 형식으로 구현을 하였다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;페이스북 메신저에서 제공하는 챗봇(chat-bot) 기능을 통해 아두이노와 같은 장비에 메시지를 주고 받는 기능을 개발해보기로 했다.&lt;/p&gt;
&lt;p&gt;가장 먼저 &lt;a href=&quot;https://developers.facebook.com/docs/mes
      
    
    </summary>
    
      <category term="IoT" scheme="https://osujin.github.io/categories/IoT/"/>
    
    
  </entry>
  
  <entry>
    <title>Synology NAS에서 예능 자동으로 다운받고 폴더별로 분류하기</title>
    <link href="https://osujin.github.io/2017/06/12/Synology-NAS%EC%97%90%EC%84%9C-%EC%98%88%EB%8A%A5-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EB%8B%A4%EC%9A%B4%EB%B0%9B%EA%B3%A0-%ED%8F%B4%EB%8D%94%EB%B3%84%EB%A1%9C-%EB%B6%84%EB%A5%98%ED%95%98%EA%B8%B0/"/>
    <id>https://osujin.github.io/2017/06/12/Synology-NAS에서-예능-자동으로-다운받고-폴더별로-분류하기/</id>
    <published>2017-06-12T00:41:59.000Z</published>
    <updated>2018-04-04T07:01:34.882Z</updated>
    
    <content type="html"><![CDATA[<p>synology 토렌트 다운로드에 RSS 다운로드 기능이 있다는것은 알았지만 다운받고 또 일일이 수동으로 분류하는것이 번거러워 잘 사용하지는 않았다.</p><p>그런데 파일 자동분류 프로그램을 만들어 다운로드 폴더를 모니터링 하고 있다가 자동으로 해당 폴더로 영상을 옮겨주는 프로그램을 만들면 좋겠다는 생각이 들어 Node JS를 이용해 만들어 보았다.</p><p>먼저 RSS 이용방법은 RooT님의 블로그를 보고 참고하면 된다. <a href="http://blog.iroot.kr/62" target="_blank" rel="noopener">Synology NAS RSS 사용법</a></p><p>RSS를 이용하여 즐겨보는 예능을 자동으로 특정폴더로 다운받도록 예약을 걸어놓고 자동분류 프로그램을 돌리면 예능들이 자동으로 이름에 맞게 폴더로 이동된다.</p><p>Node js를 이용해서 만들다 보니 한글처리에 약간의 문제가 있었는데 파일명을 그대로 사용하지 말고 buffer로 감싸주어 변환시켜주니 한글이 깨지지 않고 그대로 출력되었다.</p><p>파일을 분류하는 방법은 영상에 있는 프로그램 제목과 폴더명을 맞추도록 했는데 파일명에서 . 과 공백으로 파일명을 잘라 일일이 비교를 하는 방법을 사용하였다.</p><p>예를들어 “[tvN] 코미디 빅리그.E170.170521.720p-NEXT.mp4” 이라는 파일이 있을때 이를 split 하면 아래와 같이 분류가 되는데<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[tvN]</span><br><span class="line">코미디</span><br><span class="line">빅리그</span><br><span class="line">E170</span><br><span class="line">170521</span><br><span class="line">720p-NEXT</span><br><span class="line">mp4</span><br></pre></td></tr></table></figure></p><p>node js의 fs 모듈을 이용해 특정 폴더를 모니터링하는 watcher를 만들고 새로운 파일이 감지되면 예능 폴더에 있는 폴더 리스트를 array로 가져와 위 파일명과 폴더명을 비교하여 일치하는 것이 있으면 해당 폴더로 이동시키도록 해보니 큰 문제 없이 정상 동작하였다.</p><p>아래는 소스코드이다.</p><p>그리고 damon 으로 뛰우기 위해 forever를 이용하여 기동하였다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> dataDir = <span class="string">'[예능 폴더]'</span>;</span><br><span class="line"><span class="keyword">var</span> moveDir = <span class="string">'[토렌트로 다운받은 폴더]'</span>;</span><br><span class="line"><span class="keyword">var</span> moveList = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> walkSync = <span class="function"><span class="keyword">function</span>(<span class="params">dir, filelist</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fs = fs || <span class="built_in">require</span>(<span class="string">'fs'</span>),</span><br><span class="line">        files = fs.readdirSync(dir);</span><br><span class="line">    filelist = filelist || [];</span><br><span class="line">    files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fs.statSync(dir + <span class="string">'/'</span> + file).isDirectory()) &#123;</span><br><span class="line">            filelist = walkSync(dir + <span class="string">'/'</span> + file, filelist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            filelist.push(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fs.watch(dataDir, <span class="function"><span class="keyword">function</span>(<span class="params">event, filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileList = walkSync(moveDir,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cName = Buffer(filename, <span class="string">'binary'</span>).toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> words = cName.split(<span class="regexp">/[\s.]+/</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(event == <span class="string">"rename"</span> &amp;&amp; moveList != cName )  &#123;</span><br><span class="line"></span><br><span class="line">        fileList.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">            words.some(<span class="function"><span class="keyword">function</span> (<span class="params">p1</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> index = element.indexOf(p1);</span><br><span class="line">                <span class="keyword">if</span>(index &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(dataDir+cName, moveDir+element+<span class="string">"/"</span>+cName);</span><br><span class="line">                    fs.rename(dataDir+cName, moveDir+element+<span class="string">"/"</span>+cName,</span><br><span class="line">                        <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> (err) <span class="built_in">console</span>.error(err);</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">'renamed complete'</span>); &#125;);</span><br><span class="line"></span><br><span class="line">                    moveList = cName;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileList = walkSync(moveDir,<span class="string">""</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fileList)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;synology 토렌트 다운로드에 RSS 다운로드 기능이 있다는것은 알았지만 다운받고 또 일일이 수동으로 분류하는것이 번거러워 잘 사용하지는 않았다.&lt;/p&gt;
&lt;p&gt;그런데 파일 자동분류 프로그램을 만들어 다운로드 폴더를 모니터링 하고 있다가 자동으
      
    
    </summary>
    
      <category term="기타" scheme="https://osujin.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
    
  </entry>
  
  <entry>
    <title>HttpsURLConnection을 이용한 통신시 SSL 인증서 수동으로 지정하는 방법</title>
    <link href="https://osujin.github.io/2017/06/09/HttpsURLConnection%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%86%B5%EC%8B%A0%EC%8B%9C-SSL-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%88%98%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%A7%80%EC%A0%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/"/>
    <id>https://osujin.github.io/2017/06/09/HttpsURLConnection을-이용한-통신시-SSL-인증서-수동으로-지정하는-방법/</id>
    <published>2017-06-09T00:58:27.000Z</published>
    <updated>2018-04-04T06:13:14.043Z</updated>
    
    <content type="html"><![CDATA[<p>Https를 이용하여 데이터를 주고 받을때 SSL 인증을 해야한다.</p><p>기본적으로</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"javax.net.ssl.keyStore"</span>,context.getKeyFile().getAbsolutePath());</span><br><span class="line">System.setProperty(<span class="string">"javax.net.ssl.keyStorePassword"</span>, context.getKeyFilePassword());</span><br><span class="line">System.setProperty(<span class="string">"javax.net.ssl.keyStoreType"</span>, <span class="string">"PKCS12"</span>);</span><br><span class="line">System.setProperty(<span class="string">"http.keepAlive"</span>,<span class="string">"false”);</span></span><br></pre></td></tr></table></figure><p>이런식으로 System property를 추가해주면 HttpsURLConnection을 생성할때 자동으로 SSL인증서를 포함 시키지만 간혹 이방법이 안되는 경우가 있다.</p><p>이럴때는 수동으로 SSLContext에 keystore를 등록해주면 해결이 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">KeyStore clientStore = KeyStore.getInstance(<span class="string">"PKCS12"</span>);</span><br><span class="line">clientStore.load(<span class="keyword">new</span> FileInputStream(<span class="string">"test.p12"</span>), <span class="string">"testPass"</span>.toCharArray());</span><br><span class="line"> </span><br><span class="line">KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">kmf.init(clientStore, <span class="string">"testPass"</span>.toCharArray());</span><br><span class="line">KeyManager[] kms = kmf.getKeyManagers();</span><br><span class="line"> </span><br><span class="line">KeyStore trustStore = KeyStore.getInstance(<span class="string">"JKS"</span>);</span><br><span class="line">trustStore.load(<span class="keyword">new</span> FileInputStream(System.getProperty(<span class="string">"java.home"</span>) + <span class="string">"/lib/security/cacerts"</span>), <span class="string">"changeit"</span>.toCharArray());</span><br><span class="line"> </span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">tmf.init(trustStore);</span><br><span class="line">TrustManager[] tms = tmf.getTrustManagers();</span><br><span class="line"> </span><br><span class="line">SSLContext sslContext = <span class="keyword">null</span>;</span><br><span class="line">sslContext = SSLContext.getInstance(<span class="string">"TLS"</span>);</span><br><span class="line">sslContext.init(kms, tms, <span class="keyword">new</span> SecureRandom());</span><br><span class="line"> </span><br><span class="line">HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());</span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"https://www.testurl.com"</span>);</span><br><span class="line"> </span><br><span class="line">HttpsURLConnection urlConn = (HttpsURLConnection) url.openConnection();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Https를 이용하여 데이터를 주고 받을때 SSL 인증을 해야한다.&lt;/p&gt;
&lt;p&gt;기본적으로&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="기타" scheme="https://osujin.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
    
  </entry>
  
  <entry>
    <title>java8 Default method</title>
    <link href="https://osujin.github.io/2017/06/01/java8-default-method/"/>
    <id>https://osujin.github.io/2017/06/01/java8-default-method/</id>
    <published>2017-06-01T01:16:53.000Z</published>
    <updated>2018-04-04T05:59:56.984Z</updated>
    
    <content type="html"><![CDATA[<p>자바8에서 새로 추가된 Default method는 기존에 만들어진 interface를 implement 받는 class들에 영향을 주지 않고 interface에 새로운 항목을 추가할 수 있다.</p><p>기존에는 이미 생성된 interface에 새로운 method를 추가하려면 이를 implement 받는 모든 class들에도 Override를 해주어야 됬지만 Default method는 interface에 선언 할때에 body도 함께 만들어야 하므로 기본적으로 inerface에서 제공하는 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span></span>&#123;</span><br><span class="line">       <span class="keyword">new</span> D().hello();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"Hello from A"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">world</span><span class="params">()</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>, <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">world</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>위 코드에서 public default void hello() 이부분이 Default method를 구현한것이다. 꼭 body를 함께 생성해주어야 한다. body를 생성하지 않으면 error가 발생한다. 그리고 Default method 는 기존 interface와 마찬가지로 override 받을 수 있는데 override를 하여 새롭게 body를 구성하여 기존 interface 처럼 사용가능하다.</p><p>또한 interface는 여러개를 implement 받는것이 가능하므로 그동안 지원하지 않았던 <strong>다중상속</strong>의 기능을 Default method를 이용하여 사용 할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;자바8에서 새로 추가된 Default method는 기존에 만들어진 interface를 implement 받는 class들에 영향을 주지 않고 interface에 새로운 항목을 추가할 수 있다.&lt;/p&gt;
&lt;p&gt;기존에는 이미 생성된 interface
      
    
    </summary>
    
      <category term="Java" scheme="https://osujin.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 8 병렬처리와 성능에 대해서</title>
    <link href="https://osujin.github.io/2017/05/31/Java-8-%EB%B3%91%EB%A0%AC%EC%B2%98%EB%A6%AC%EC%99%80-%EC%84%B1%EB%8A%A5%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C/"/>
    <id>https://osujin.github.io/2017/05/31/Java-8-병렬처리와-성능에-대해서/</id>
    <published>2017-05-31T06:10:01.000Z</published>
    <updated>2018-04-04T05:53:27.749Z</updated>
    
    <content type="html"><![CDATA[<p>자바 8의 Stream API에서 사용가능한 병렬처리 함수인 parallel를 이용할때 확인해야 할 점이 있다.</p><p>1부터 n 까지 더하는 작업을 단순 반복문 , Stream parallel 를 이용한 코드의 동작 시간을 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 단순 반복문</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">iterativeSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">         result += i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//2. Parallel 를 이용하여 병령처리한 작업</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parallelSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Stream.iterate(<span class="number">1L</span>, i -&gt; i + <span class="number">1</span>).limit(n).parallel().reduce(Long::sum).get();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//출처 Java 8 in Action</span></span><br></pre></td></tr></table></figure><p>결과<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Iterative Sum done in: 3 msecs</span><br><span class="line"> </span><br><span class="line">2.  Parallel forkJoinSum done in: 95 msecs</span><br></pre></td></tr></table></figure></p><p>3개의 메소드를 실행 해보면 1번이 가장빠르다는것을 확인 할 수 있는데 이 예제에서 iterate 연산은 본질적으로 순차적으로 일어나기 때문에 병령처리를 해도 큰 효과를 보기 힘들고 Steam을 이용하여 계산을 할때는 기본형 데이터 타입이 아닌 참조형으로 변환하는 과정이 있기때문에 더 많은 리소스가 사용된다.</p><p>자바8을 공부하며 기존 소스를 자바8로 리펙토링 하려 했는데 무턱대고 적용하기전 확인이 필요하다.</p><p>Parallel를 이용한 코드의 성능을 높이기 위해선 기본형 long 을 직접 사용하는 “<em>LongStream.rangeClosed</em>“ 를 이용하면 성능을 높일수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parallelRangedSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">1</span>, n).parallel().reduce(Long::sum).getAsLong();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>하지만 위 코드도 단순 반복문보다 빠르다고 장담 할 수는 없는데 이는 멀티코어간 데이터교환시 발생하는 비용때문이다. 코어간의 데이터 이동은 큰 작업이고 병렬처리를 할때에 코어간 데이터 교환보다 오래걸리는 작업을 병령처리로 나누어 작업하는게 효율적이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;자바 8의 Stream API에서 사용가능한 병렬처리 함수인 parallel를 이용할때 확인해야 할 점이 있다.&lt;/p&gt;
&lt;p&gt;1부터 n 까지 더하는 작업을 단순 반복문 , Stream parallel 를 이용한 코드의 동작 시간을 확인해보자.&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://osujin.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Intel Edison firmware Update 실패시 후속 조치방법</title>
    <link href="https://osujin.github.io/2017/04/11/Intel-Edison-firmware-Update-%EC%8B%A4%ED%8C%A8%EC%8B%9C-%ED%9B%84%EC%86%8D-%EC%A1%B0%EC%B9%98%EB%B0%A9%EB%B2%95/"/>
    <id>https://osujin.github.io/2017/04/11/Intel-Edison-firmware-Update-실패시-후속-조치방법/</id>
    <published>2017-04-11T02:39:25.000Z</published>
    <updated>2018-04-04T02:06:47.310Z</updated>
    
    <content type="html"><![CDATA[<p>Intel Edison 펌웨어를 업데이트하다 리눅스 커널이 망가져 반쪽의 기능밖에 못하는 상황이 되었다.</p><p>usb 연결로 boot img를 업로드하려해도 인식 조차안되는 상황..</p><p>그래서 아예 새로운 커널로 새로 로드를 한뒤 다시 펌웨어 업데이트를 하니 정상적으로 업데이트가 진행 되었다.</p><p>intel edison 공식 메뉴얼에서 약간 수정을 하면 되는데</p><p><a href="https://software.intel.com/en-us/flashing-firmware-on-your-intel-edison-board-mac-os-x" target="_blank" rel="noopener">Flashing the firmware on a system with Mac<em> OS X</em> (manual process)</a></p><p>위 사이트에서 Yocto* complete image 파일 대신</p><p><a href="https://emutex.com/packages/ubilinux-edison-150309.tar.gz" target="_blank" rel="noopener">ubilinux.tar.gz</a> 이 파일을 다운받아 압축을 풀고 flashall.sh 를 실행하면 된다.</p><p>쉘을 실행한뒤에 <strong>“Please plug and reboot the board”</strong> 이라는 문구가 나올때 edison board를 맥과 연결해줘야 접속이 된다.</p><p>새로운 boot loader가 업로드 되고 sucess가 뜨면 연결을 해지한뒤</p><p><a href="https://software.intel.com/edison-config/osx/latest" target="_blank" rel="noopener">Intel_Edison_Setup_Mac_v2016.2.013</a> 을 다운받아 최신 버전의 yocto linux 를 설치해주면 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Intel Edison 펌웨어를 업데이트하다 리눅스 커널이 망가져 반쪽의 기능밖에 못하는 상황이 되었다.&lt;/p&gt;
&lt;p&gt;usb 연결로 boot img를 업로드하려해도 인식 조차안되는 상황..&lt;/p&gt;
&lt;p&gt;그래서 아예 새로운 커널로 새로 로드를 한뒤
      
    
    </summary>
    
      <category term="IoT" scheme="https://osujin.github.io/categories/IoT/"/>
    
    
  </entry>
  
  <entry>
    <title>iftop 소스 설치</title>
    <link href="https://osujin.github.io/2017/04/04/iftop-%EC%86%8C%EC%8A%A4-%EC%84%A4%EC%B9%98/"/>
    <id>https://osujin.github.io/2017/04/04/iftop-소스-설치/</id>
    <published>2017-04-04T02:06:52.000Z</published>
    <updated>2018-04-04T06:10:06.601Z</updated>
    
    <content type="html"><![CDATA[<p>인터넷이 안되는 내부망에서 iftop을 설치가 필요할때 소스 설치를 하는 방법이다.</p><p>설치 환경은 centos 6.8 64bit 에서 진행하였다.</p><p>필요한 파일은</p><ul><li>iftop-0.17.tar.gz</li><li>libpcap-1.7.4.tar</li></ul><p>이고 root 권한으로 설치를 진행한다.</p><p>설치파일 : <a href="/image/2017/04/iftop-0.17.tar.gz">iftop-0.17.tar Download</a> , <a href="/image/2017/04/libpcap-1.7.4.tar">libpcap-1.7.4 Download</a></p><p>일단 libpcap-1.7.4.tar 파일을 먼저 설치해서 pcap 라이브러리를 설치해줘야 한다.</p><p>libpcap 라이브러리를 설치할때 flex , bison 이 필요하다고 에러가 나오는데 메뉴얼에 이 두개는 제외하고 설치하는 방법이 나와있다.</p><p><strong>libpcap 설치방법</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># tar xf libpcap-1.7.4.tar</span><br><span class="line"># cd libpcap-1.7.4</span><br><span class="line"># ./configure --without-flex --without-bison</span><br><span class="line"># make</span><br><span class="line"># make install</span><br></pre></td></tr></table></figure><p><strong>iftop 설치 방법</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># tar xf iftop-0.17.tar.gz</span><br><span class="line"># cd iftop-0.17</span><br><span class="line"># ./configure &amp;&amp; make</span><br></pre></td></tr></table></figure><p>추가적으로 최근에 개발된 iftop 1.0 버전을 설치하는 방법이다.</p><p>1&#46;0 정식 버전은 없고 현재 pre4 버전이 최신 버전인데 이버전을 설치하려면 ncurses 가 필요하다.</p><p>설치파일 : <a href="/file/ncurses-6.0.tar.gz">ncurses-6.0.tar Download</a> , <a href="/file/iftop-1.0pre4.tar.gz">iftop-1.0pre4.tar Download</a></p><p><strong>ncurses 설치방법</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># tar xf ncurses-6.0.tar.gz</span><br><span class="line"># cd ncurses-6.0</span><br><span class="line"># ./configure --with-normal --with-debug --enable-overwrite</span><br><span class="line"># make install.libs</span><br></pre></td></tr></table></figure><p><strong>iftop-1.0pre4 설치방법</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># tar xf iftop-1.0pre4.tar.gz   </span><br><span class="line"># cd iftop-1.0pre4   </span><br><span class="line"># ./configure &amp;&amp; install</span><br></pre></td></tr></table></figure><p><strong>Tip</strong></p><p>centos 계열에서 소스설치가 안될때는 rpm으로 설치가 가능한데</p><p>yum install yum-downloadonly 을 설치하여 rpm 다운로드 프로그램을 설치한뒤</p><p>yum install iftop –downloadonly –downloaddir=/home/user/Downloads</p><p>이런식으로 rpm 을 특정경로에 다운받아 둘 수 있다. 이를 사용하려면 다운받으려는 rpm 이 미설치된 상태어야 한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;인터넷이 안되는 내부망에서 iftop을 설치가 필요할때 소스 설치를 하는 방법이다.&lt;/p&gt;
&lt;p&gt;설치 환경은 centos 6.8 64bit 에서 진행하였다.&lt;/p&gt;
&lt;p&gt;필요한 파일은&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iftop-0.17.tar.gz&lt;/li
      
    
    </summary>
    
      <category term="기타" scheme="https://osujin.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
    
  </entry>
  
  <entry>
    <title>ODL karaf 에서 impl 모듈만 빌드해서 다시 띄우는 방법</title>
    <link href="https://osujin.github.io/2017/03/28/ODL-karaf-%EC%97%90%EC%84%9C-impl-%EB%AA%A8%EB%93%88%EB%A7%8C-%EB%B9%8C%EB%93%9C%ED%95%B4%EC%84%9C-%EB%8B%A4%EC%8B%9C-%EB%9D%84%EC%9A%B0%EB%8A%94-%EB%B0%A9%EB%B2%95/"/>
    <id>https://osujin.github.io/2017/03/28/ODL-karaf-에서-impl-모듈만-빌드해서-다시-띄우는-방법/</id>
    <published>2017-03-28T04:39:03.000Z</published>
    <updated>2018-04-04T05:41:37.441Z</updated>
    
    <content type="html"><![CDATA[<p>ODL 개발시 impl 쪽을 수정할때마다 매번 프로젝트 전체를 빌드하고 다시 karaf를 띄우는게 시간이 오래걸려 확인해보니</p><p>karaf 내에서 각 bundle별로 죽였다 다시 띄울때 jar 파일만 교체해주면 전체를 빌드하지 않아도 손쉽게 적용이 가능하다.</p><ul><li>~/karaf/target/assembly/system/org/opendaylight/hello/hello-service/0.1.0-SNAPSHOT/hello-Service-0.1.0-SNAPSHOT.jar</li></ul><p>위와 같이 karaf 폴더안에 system 폴더까지 들어가보면 프로젝트의 groupId의 경로에 각종 모듈들의 jar 파일이 존재한다. 여기에 포함되어있는 jar 파일만 교체를 해주면 karaf 를 재기동 하지 않아도 수정된 bundle을 다시 띄울수 있다.</p><p>띄우는 방법은 우선 아래 명령어를 이용하여 자신이 수정한 모듈을 찾는다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feature:list -i</span><br></pre></td></tr></table></figure><p>내가 수정하려는 bundle의 예는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">odl-helloService-api            | 0.1.0-SNAPSHOT   | x         | odl-helloService-0.1.0-SNAPSHOT      | OpenDaylight :: helloService :: api</span><br><span class="line">odl-helloService                | 0.1.0-SNAPSHOT   | x         | odl-helloService-0.1.0-SNAPSHOT      | OpenDaylight :: helloService</span><br><span class="line">odl-helloService-rest           | 0.1.0-SNAPSHOT   | x         | odl-helloService-0.1.0-SNAPSHOT      | OpenDaylight :: helloService :: REST</span><br><span class="line">odl-helloService-ui             | 0.1.0-SNAPSHOT   | x         | odl-helloService-0.1.0-SNAPSHOT      | OpenDaylight :: helloService :: UI</span><br></pre></td></tr></table></figure><p>이제 수정하려는 모듈인 odl-helloService 을 uninstall 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feature:uninstall odl-helloService</span><br></pre></td></tr></table></figure><p>그리고 위에 설명한것 처럼 수정된 jar 파일을 경로에 맞게 옮겨놓고 다시 아래 명령어로 feature를 install 하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feature:install odl-helloService</span><br></pre></td></tr></table></figure><p>옮겨진 jar 파일명은 당연히 기존 파일명과 동일하게 맞춰야한다.</p><p>위고하정이 정상적으로 수행이 되면 프로젝트 전체를 빌드하지 않고 특정 module만 재배포가 가능하다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ODL 개발시 impl 쪽을 수정할때마다 매번 프로젝트 전체를 빌드하고 다시 karaf를 띄우는게 시간이 오래걸려 확인해보니&lt;/p&gt;
&lt;p&gt;karaf 내에서 각 bundle별로 죽였다 다시 띄울때 jar 파일만 교체해주면 전체를 빌드하지 않아도 손
      
    
    </summary>
    
      <category term="OpenDayLight" scheme="https://osujin.github.io/categories/OpenDayLight/"/>
    
    
  </entry>
  
  <entry>
    <title>ODL에서 외부 라이브러리 사용하기</title>
    <link href="https://osujin.github.io/2017/03/28/ODL%EC%97%90%EC%84%9C-%EC%99%B8%EB%B6%80-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"/>
    <id>https://osujin.github.io/2017/03/28/ODL에서-외부-라이브러리-사용하기/</id>
    <published>2017-03-28T04:27:09.000Z</published>
    <updated>2018-04-04T06:50:52.374Z</updated>
    
    <content type="html"><![CDATA[<p>ODL SB plugin을 만들면서 외부 라이브러리를 거의 필수적으로 사용하게 되는데 karaf상에서 외부라이브러리를 사용하는 방식이 다소 복잡하여 정리를 하였다.</p><p>내가 필요한 라이브라리는 아래와 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.http.HttpMethod;</span><br><span class="line">import org.springframework.http.ResponseEntity;</span><br><span class="line">import org.springframework.http.client.ClientHttpRequest;</span><br><span class="line">import org.springframework.util.LinkedMultiValueMap;</span><br><span class="line">import org.springframework.util.MultiValueMap;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line">import com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line">import com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br></pre></td></tr></table></figure><p>위 라이브러리들은</p><ul><li>org.springframework</li><li>com.fasterxml.jackson.core</li></ul><p>에 포함된 라이브러리 인데 기존 자바 프로젝트처럼 단순히 dependeny만 잡아준다고해서 karaf에서 bundle로 해당 SB plugin을 기동하려고 하면 라이브러리를 추가하라는 에러가 나온다.</p><p>그래서 OSGi Framework 에서 외부라이브러리를 embedded 해주는 apache felix를 pom.xml에 설정을 해주어야 정상적으로 사용이 가능하다.</p><p>위에 명시된 두개의 외부 라이브러리를 사용하기 위해 pom.xml에 dependency를 잡아주고 추가적으로 build 설정에 felix를 추가해주었다. 설정내용은 다음과 같다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.felix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-bundle-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">instructions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Export-Package</span>&gt;</span></span><br><span class="line">              org.springframework.*,</span><br><span class="line">              com.fasterxml.jackson.*</span><br><span class="line">            <span class="tag">&lt;/<span class="name">Export-Package</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Import-Package</span>&gt;</span></span><br><span class="line">              *;resolution:=optional</span><br><span class="line">            <span class="tag">&lt;/<span class="name">Import-Package</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Embed-Dependency</span>&gt;</span></span><br><span class="line">              jackson-databind;type=!pom;inline=false,</span><br><span class="line">              spring-web;type=!pom;inline=false</span><br><span class="line">            <span class="tag">&lt;/<span class="name">Embed-Dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Embed-Transitive</span>&gt;</span></span><br><span class="line">              true</span><br><span class="line">            <span class="tag">&lt;/<span class="name">Embed-Transitive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Include-Resource</span>&gt;</span></span><br><span class="line">              &#123;maven-resources&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">Include-Resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">_removeheaders</span>&gt;</span></span><br><span class="line">              Embed-Dependency,Include-Resource</span><br><span class="line">            <span class="tag">&lt;/<span class="name">_removeheaders</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">instructions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>각 테그들에 대한 내용은 아래 문서를 보고 확인을 해봐야 할것 같다.</p><p><a href="http://felix.apache.org/documentation/subprojects/apache-felix-maven-bundle-plugin-bnd.html" target="_blank" rel="noopener">Apache Felix Maven Bundle Plugin (BND) Documentation</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ODL SB plugin을 만들면서 외부 라이브러리를 거의 필수적으로 사용하게 되는데 karaf상에서 외부라이브러리를 사용하는 방식이 다소 복잡하여 정리를 하였다.&lt;/p&gt;
&lt;p&gt;내가 필요한 라이브라리는 아래와 같다.&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
      <category term="OpenDayLight" scheme="https://osujin.github.io/categories/OpenDayLight/"/>
    
    
  </entry>
  
  <entry>
    <title>ODL(OpenDayLight) 기본 튜토리얼 #7_4 – singletonsimple RPC Route 기능 설명</title>
    <link href="https://osujin.github.io/2017/03/18/ODL(OpenDayLight)-%EA%B8%B0%EB%B3%B8-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-7_4%E2%80%93singletonsimple-RPC-Route-%EA%B8%B0%EB%8A%A5-%EC%84%A4%EB%AA%85/"/>
    <id>https://osujin.github.io/2017/03/18/ODL(OpenDayLight)-기본-튜토리얼-7_4–singletonsimple-RPC-Route-기능-설명/</id>
    <published>2017-03-18T06:08:10.000Z</published>
    <updated>2018-04-04T05:51:32.862Z</updated>
    
    <content type="html"><![CDATA[<p>singletons cluster의 구조는 다음과 같다.</p><p><img src="/image/2017/03/스크린샷-2017-03-13-오후-4.25.10.png" alt=""> [사진 1]</p><p>3개의 docker instance에 singletonsimple 를 배포하고 기동하면 자동으로 cluster 설정이 이루어 지고 Leader Node가 설정되어 진다.</p><p>Leader Node는 3개의 Node중에 선택되어지고 Leader Node가 죽으면 다른 Node가 Leader가 된다.</p><p>singletonsimple 프로젝트의 yang 파일을 보면 총 3개의 RPC가 존재한다.</p><ul><li>global-rpc</li><li>routed.rpc</li><li>local-rpc</li></ul><p>먼저 rpc를 등록해주는 SingletonSimpleProvider.java 파일의 소스코드의 일부분을 살펴보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonSimpleProvider</span> <span class="keyword">implements</span> <span class="title">ClusterSingletonService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClusterSingletonServiceRegistration cssRegistration;</span><br><span class="line"> </span><br><span class="line">... </span><br><span class="line">... </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instantiateServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">"We take Leadership"</span>);</span><br><span class="line">        Preconditions.checkState(globalRpcServiceReg == <span class="keyword">null</span>,</span><br><span class="line">                <span class="string">"Unexpected state: we have active GlobalRpcServiceRegistration"</span>);</span><br><span class="line">        Preconditions.checkState(routedRpcServiceReg == <span class="keyword">null</span>,</span><br><span class="line">                <span class="string">"Unexpected state: we have active RoutedRpcServiceRegistration"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Create a new instance of the Global RPC Service and register it with the RPC registry</span></span><br><span class="line">        globalRpcServiceReg = rpcProviderRegistry.addRpcImplementation(GlobalRpcService.class,</span><br><span class="line">                <span class="keyword">new</span> GlobalRpcServiceImpl(hostInfo));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Create a new instance of the Routed RPC Service and register it and its path with the RPC registry</span></span><br><span class="line">        routedRpcServiceReg = rpcProviderRegistry.addRoutedRpcImplementation(RoutedRpcService.class,</span><br><span class="line">                <span class="keyword">new</span> RoutedRpcServiceImpl(hostInfo));</span><br><span class="line">        <span class="comment">/* The route identifier for the registered path is as follows:</span></span><br><span class="line"><span class="comment">         * routed-rpc:rpc-member[routed-rpc:name="rpc-key"]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        routedRpcServiceReg.registerPath(RoutedRpcContext.class,</span><br><span class="line">                InstanceIdentifier.builder(RpcMember.class, <span class="keyword">new</span> RpcMemberKey(<span class="string">"rpc-key"</span>)).build());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>위 클래스는 ClusterSingletonService를 implements 받는데 이 클래스에서 Override 된 instantiateServiceInstance 메소드에 등록된 RPC가 cluster로 묶인 Node들에서 공유가 되는 것이다.</p><p>위에서 말했듯이 자동으로 Leader Node가 설정되어지는데 리더로 설정된 Node에서만 instantiateServiceInstance 가 실행되고 나머지 Node들은 실행되지 않는다.</p><p>공식 문서에 따르면 ClusterSingletonService 에는 EOS(Entity Ownership Service)에대한 복잡한 알고리즘을 처리하는 로직이 포함되어 Leader Node가 죽을 경우 살아있는 다른 Node가 Leader가 되도록 한다.</p><h2 id="RPC-기능-설명"><a href="#RPC-기능-설명" class="headerlink" title="RPC 기능 설명"></a>RPC 기능 설명</h2><p>singletonsimple 프로젝트를 보면 3개의 RPC가 선언 되어 있다고했다. 각 RPC에 대해 자세히 알아보자</p><p>1&#46;local-rpc</p><ul><li>가장 기본적인 RPC 기능을 한다. local-rpc는 Provider class에 init 메소드에 등록이 되어 각 Node에서 karaf를 구동시킬때 자동으로 등록되어져 REST 방식으로 호출하여 사용가능하다.</li></ul><p>2&#46;global-rpc</p><ul><li><p>global-rpc는 Provider class의 instantiateServiceInstance 메소드에서 등록이 되는데 instantiateServiceInstance메소드는 Leader Node에서만 실행이 된다고 하였다. Leader Node 가 instantiateServiceInstance 메소드를 실행하면 global-rpc 가 SAL에 등록이 되고 나머지 두개의 Node에도 광고가 된다. 실제로는 Leader Node에만 global-rpc가 등록되어 진것이지만 다른 두개의 Node에서도 해당 RPC를 사용 할 수 있다.</p></li><li><p>만약 Leader Node가 죽었을 경우 다른 Node가 Leader 가 되고 instantiateServiceInstance 이 실행되어 global-rpc가 등록되어진다.</p></li><li><p>위 사진1 에서는 Node1 이 Leader가 된 경우에 Leader1의 Global RPC만 접근이 가능하여 RESTCONF <---> Global RPC 로 되어있고 Node2,3 는 RESTCONF <-x-> Global RPC 라고 되어진것이 바로 이뜻이다.</-x-></---></p></li></ul><p>global-rpc를 실제로 동작시켜 보면 다음과 같다.</p><p><img src="/image/2017/03/사진2.png" alt=""> [사진2]</p><p><img src="/image/2017/03/사진3.png" alt=""> [사진3]</p><p>사진 2를 보면 2번 Node(172.17.0.3)에서 global-rpc를 호출 하였고 이에 대한 응답으로 다음 결과를 받았다.<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"output"</span>: &#123;</span><br><span class="line">      <span class="attr">"ip-address"</span>: [</span><br><span class="line">        <span class="string">"fe80:0:0:0:42:acff:fe11:2%eth0"</span>,</span><br><span class="line">        <span class="string">"172.17.0.2"</span>,</span><br><span class="line">        <span class="string">"0:0:0:0:0:0:0:1%lo"</span>,</span><br><span class="line">        <span class="string">"127.0.0.1"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"host-name"</span>: <span class="string">"member-1"</span>,</span><br><span class="line">      <span class="attr">"output-param"</span>: <span class="string">"Some input-param"</span>,</span><br><span class="line">      <span class="attr">"invocations"</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="attr">"jvm-uptime"</span>: <span class="number">145673203</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>응답받은 결과를 보면 host-name = member-1 , ip = 172.17.0.2 으로 출력된것을 보아 첫번째 Node의 RPC가 호출된것으로 보인다.</p><p>사진3은 ODL의 로그인데 실제로 2번 Node 에서 Global rpc를 호출 했지만 실제로 응답한것은 1번 Node라는것을 확인 할 수 있다.</p><p>다음으로 1번 Node를 강제로 죽여 Leader Node를 변경하여 보자.</p><p><img src="/image/2017/03/사진4.png" alt=""></p><p>[사진4]</p><p>위 그림4를 보면 1번 Node의 ODL을 죽이면 자동으로 2,3번 Node로 1번 Node가 죽었다는 Notification이 날라가고 Leader 선출 과정을 거쳐 2번 Node가 Leader로 선출 되었음을 알 수 있다.</p><p>3&#46;routed-rpc</p><ul><li><p>routed rpc의 동작방식은 global rpc와 거의 동일하다. 다른점이 있다면 instantiateServiceInstance메소드에서 RPC를 등록할때에 RpcMemberKey를 설정할수 있는데 routed-rpc를 호출할때 여기서 설정한 key 값을 이용해 호출을 할 수 있다.</p></li><li><p>routed-rpc 역시 Leader Node에서만 등록이되어 사용이 가능하고 호출은 어떤 노드에서나 가능하다.</p></li></ul><p><img src="/image/2017/03/사진5.png" alt=""></p><p>[사진5]</p><p>링크 : <a href="https://wiki.opendaylight.org/view/OpenDaylight_OpenFlow_Plugin:Clustering_Singleton" target="_blank" rel="noopener">OpenDaylight OpenFlow Plugin:Clustering Singleton</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;singletons cluster의 구조는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/2017/03/스크린샷-2017-03-13-오후-4.25.10.png&quot; alt=&quot;&quot;&gt; [사진 1]&lt;/p&gt;
&lt;p&gt;3개의 docker instance
      
    
    </summary>
    
      <category term="OpenDayLight" scheme="https://osujin.github.io/categories/OpenDayLight/"/>
    
    
  </entry>
  
  <entry>
    <title>ODL(OpenDayLight) 기본 튜토리얼 #7_3 – clustering 설정</title>
    <link href="https://osujin.github.io/2017/03/17/ODL(OpenDayLight)-%EA%B8%B0%EB%B3%B8-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-7_3-%E2%80%93-clustering-%EC%84%A4%EC%A0%95/"/>
    <id>https://osujin.github.io/2017/03/17/ODL(OpenDayLight)-기본-튜토리얼-7_3-–-clustering-설정/</id>
    <published>2017-03-17T08:11:02.000Z</published>
    <updated>2018-04-04T05:47:33.892Z</updated>
    
    <content type="html"><![CDATA[<p>앞선 예제에서 사용했던 hello 프로젝트를 clustering을 이용하도록 구현해보자.</p><p>목표는 global-rpc,routed-rpc 구현과 datastore 공유이다.</p><p>hello 프로젝트에 아무런 설정을 하지 않고</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook -i hosts playbook_hello.yaml</span><br></pre></td></tr></table></figure><p>명령어를 이용하여 3개의 docker instance로 배포를한뒤 karaf를 실행시키고 hello-world-write RPC 를 이용하여 datastore에 데이터를 저장하면 3개의 노드 전부 datastore가 복제된다.</p><p>DataChangeListener의 경우에는 3개 Node에서 전부 실행 되는게 아니라 특정 Node 한곳에서만 실행이 되는듯 해보이는데 이건 좀더 분석을 해봐야 할것 같다.</p><hr><p><strong>이제 coretutorials에 있는 singletonsimple 을 직접 hello 프로젝트에 구현을 해보자</strong></p><p>일단 기존에 생성된 hello 프로젝트는 ODL lithium 버전으로 만들어져서 이걸 boron 버전으로 변경해줘야 한다. 그런데 lithium 버전은 blueprint를 사용하지 않기 때문에 수동으로 impl 모듈에 blueprint.xml 파일을 넣어주고 기존에 만들어진 module yang 관련 파일은 삭제를 해줘야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">impl/src/main 하위에 resources 를 만들고 폴더명이 org/opendaylight/blueprint 인 package 폴더를 만들고 impl-blueprint.xml 파일을 만들어 준다.</span><br><span class="line"></span><br><span class="line">폴더를 생성할때 꼭 확인을 해야 할것이 폴더명이 org.opendaylight.blueprint 으로 되지 않았는지 확인이 필요하다. 폴더구조의 형태로 만들어져야 한다.</span><br></pre></td></tr></table></figure><p>impl-blueprint.xml 파일 내용은 아래와 같다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- vi: set et smarttab sw=4 tabstop=4: --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Copyright © 2016 Copyright(c) Chun, Inc. and others. All rights reserved.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">This program and the accompanying materials are made available under the</span></span><br><span class="line"><span class="comment">terms of the Eclipse Public License v1.0 which accompanies this distribution,</span></span><br><span class="line"><span class="comment">and is available at http://www.eclipse.org/legal/epl-v10.html</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blueprint</span> <span class="attr">xmlns</span>=<span class="string">"http://www.osgi.org/xmlns/blueprint/v1.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:odl</span>=<span class="string">"http://opendaylight.org/xmlns/blueprint/v1.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">odl:use-default-for-reference-types</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">reference</span> <span class="attr">id</span>=<span class="string">"dataBroker"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">interface</span>=<span class="string">"org.opendaylight.controller.md.sal.binding.api.DataBroker"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">odl:type</span>=<span class="string">"default"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">reference</span> <span class="attr">id</span>=<span class="string">"rpcRegistry"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">interface</span>=<span class="string">"org.opendaylight.controller.sal.binding.api.RpcProviderRegistry"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">reference</span> <span class="attr">id</span>=<span class="string">"notificationService"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">interface</span>=<span class="string">"org.opendaylight.controller.md.sal.binding.api.NotificationPublishService"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">reference</span> <span class="attr">id</span>=<span class="string">"clusterSingletonService"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">interface</span>=<span class="string">"org.opendaylight.mdsal.singleton.common.api.ClusterSingletonServiceProvider"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"provider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.opendaylight.hello.impl.HelloProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">argument</span> <span class="attr">ref</span>=<span class="string">"dataBroker"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">argument</span> <span class="attr">ref</span>=<span class="string">"rpcRegistry"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">argument</span> <span class="attr">ref</span>=<span class="string">"notificationService"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">argument</span> <span class="attr">ref</span>=<span class="string">"clusterSingletonService"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">blueprint</span>&gt;</span></span><br></pre></td></tr></table></figure><p>impl-blueprint.xml 파일에서 수정해야 할 부분은 bean 설정에서 class 명을 자신이 생성한 provider class와 일치해주면 된다.</p><p>blueprint 설정이 끝났으면 기존에 lithium 버전에서 사용했던 파일들을 삭제해줘야 정상적으로 blueprint 사용이 가능하다.</p><h4 id="삭제할-파일-및-폴"><a href="#삭제할-파일-및-폴" class="headerlink" title="삭제할 파일 및 폴"></a>삭제할 파일 및 폴</h4><ul><li>test 폴더</li><li>main/yang 폴더</li><li>config 폴더</li><li>java/org/opendaylight 하위에 있는 yang 풀더</li></ul><p>다음으로 각 모듈의 pom 파일을 수정해야 한다.</p><ul><li>impl 모듈의 pom.xml : version -&gt; <strong>0&#46;5.2-Boron-SR2</strong> 으로 변경</li><li>root pom.xml : version -&gt; <strong>1&#46;7.2-Boron-SR2</strong> 으로 변경</li><li>api 모듈의 pom.xml : version -&gt; <strong>0&#46;9.2-Boron-SR2</strong> 으로 변경</li><li>artifacts 모듈의 pom.xml : version -&gt; <strong>1&#46;8.0-SNAPSHOT</strong> 으로 변경</li><li>karaf 모듈의 pom.xml : version -&gt; <strong>1&#46;7.2-Boron-SR2</strong> 으로 변경</li><li>feature 모듈의 pom.xml : version -&gt; <strong>1&#46;7.2-Boron-SR2</strong> 으로 변경 , properties tag 안의 내용을 아래와 같이 변경</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mdsal.model.version</span>&gt;</span>0.10.0-SNAPSHOT<span class="tag">&lt;/<span class="name">mdsal.model.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mdsal.version</span>&gt;</span>1.5.0-SNAPSHOT<span class="tag">&lt;/<span class="name">mdsal.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">restconf.version</span>&gt;</span>1.5.0-SNAPSHOT<span class="tag">&lt;/<span class="name">restconf.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">yangtools.version</span>&gt;</span>1.1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">yangtools.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dlux.version</span>&gt;</span>0.5.0-SNAPSHOT<span class="tag">&lt;/<span class="name">dlux.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configfile.directory</span>&gt;</span>etc/opendaylight/karaf<span class="tag">&lt;/<span class="name">configfile.directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>다음엔 HelloProvider.java 파일을 boron 버전에 맞게 수정해줘야 한다.</p><p>아래 코드는 소스의 일부분인데 implements 부분이 변경 되었고 생성자로 blueprint 에서 넘겨주는 값을 받도록 설정 하였다.</p><p>그리고 ClusterSingletonService 인터페이스의 메소드인 instantiateServiceInstance 메소드에 global rpc 서비스를 등록해주어 singleton cluster 사용을 하도록 수정해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProvider</span> <span class="keyword">implements</span> <span class="title">ClusterSingletonService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(HelloProvider.class);</span><br><span class="line">    <span class="keyword">private</span> DataBroker db;</span><br><span class="line">    <span class="keyword">private</span> RpcRegistration&lt;HelloService&gt; helloService;</span><br><span class="line">    <span class="keyword">private</span> InstanceIdentifier&lt;HelloWorld&gt; path;</span><br><span class="line">    <span class="keyword">private</span> ListenerRegistration&lt;DataChangeListener&gt; data_change_listener;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HostInformation hostInfo = <span class="keyword">new</span> HostInformation();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//boron version</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcProviderRegistry rpcProviderRegistry;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NotificationPublishService notificationPublishService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterSingletonServiceProvider clusterSingletonServiceProvider;</span><br><span class="line">    <span class="keyword">private</span> ClusterSingletonServiceRegistration cssRegistration;</span><br><span class="line">    <span class="keyword">private</span> RpcRegistration&lt;GlobalRpcService&gt; globalRpcServiceReg;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceGroupIdentifier IDENT = ServiceGroupIdentifier.create(<span class="string">"Brm"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloProvider</span><span class="params">(<span class="keyword">final</span> DataBroker dataBroker,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">final</span> RpcProviderRegistry rpcProviderRegistry,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">final</span> NotificationPublishService notificationPublishService,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">final</span> ClusterSingletonServiceProvider clusterSingletonServiceProvider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.db = dataBroker;</span><br><span class="line">        <span class="keyword">this</span>.rpcProviderRegistry = rpcProviderRegistry;</span><br><span class="line">        <span class="keyword">this</span>.notificationPublishService = notificationPublishService;</span><br><span class="line">        <span class="keyword">this</span>.clusterSingletonServiceProvider = clusterSingletonServiceProvider;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">"HelloProvider Session Initiated"</span>);</span><br><span class="line">        HelloWorldImpl helloWorldImpl=<span class="keyword">new</span> HelloWorldImpl();</span><br><span class="line">        <span class="keyword">this</span>.path=helloWorldImpl.HELLO_IID;</span><br><span class="line">        helloWorldImpl.setDb(<span class="keyword">this</span>.db);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//registerDataChangeListener(접근하고자 하는 데이터 트리 종류(config or operational), 데이터 트리 PATH(InstanceIdentifier로 정의),실행될 객체, 변화감지 범위);</span></span><br><span class="line">        <span class="keyword">this</span>.data_change_listener=<span class="keyword">this</span>.db.registerDataChangeListener(LogicalDatastoreType.CONFIGURATION,path,helloWorldImpl,DataChangeScope.SUBTREE);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//boron</span></span><br><span class="line">        cssRegistration = clusterSingletonServiceProvider.registerClusterSingletonService(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.helloService = rpcProviderRegistry.addRpcImplementation(HelloService.class,helloWorldImpl);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">"HelloProvider Closed"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (cssRegistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cssRegistration.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">                LOG.warn(<span class="string">"Unexpected close exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            cssRegistration = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (helloService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            helloService.close();</span><br><span class="line">            helloService = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instantiateServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">"We take Leadership"</span>);</span><br><span class="line">        Preconditions.checkState(globalRpcServiceReg == <span class="keyword">null</span>,</span><br><span class="line">                <span class="string">"Unexpected state: we have active GlobalRpcServiceRegistration"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Create a new instance of the Global RPC Service and register it with the RPC registry</span></span><br><span class="line">        globalRpcServiceReg = rpcProviderRegistry.addRpcImplementation(GlobalRpcService.class,</span><br><span class="line">                <span class="keyword">new</span> GlobalRpcServiceImpl(hostInfo));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListenableFuture&lt;Void&gt; <span class="title">closeServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">"We lost Leadership"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Unregister the Global RPC instance</span></span><br><span class="line">        <span class="keyword">if</span> (globalRpcServiceReg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            globalRpcServiceReg.close();</span><br><span class="line">            globalRpcServiceReg = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Futures.immediateFuture(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceGroupIdentifier <span class="title">getIdentifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> IDENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>global-rpc를 사용하기 위해서는 features.xml 에 odl-mdsal-clustering 를 등록해줘야 한다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">feature</span> <span class="attr">name</span>=<span class="string">'odl-hello'</span> <span class="attr">version</span>=<span class="string">'$&#123;project.version&#125;'</span> <span class="attr">description</span>=<span class="string">'OpenDaylight :: hello'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">feature</span> <span class="attr">version</span>=<span class="string">'$&#123;mdsal.version&#125;'</span>&gt;</span>odl-mdsal-broker<span class="tag">&lt;/<span class="name">feature</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">feature</span> <span class="attr">version</span>=<span class="string">'$&#123;project.version&#125;'</span>&gt;</span>odl-hello-api<span class="tag">&lt;/<span class="name">feature</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">feature</span> <span class="attr">version</span>=<span class="string">'$&#123;mdsal.version&#125;'</span>&gt;</span>odl-mdsal-clustering<span class="tag">&lt;/<span class="name">feature</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bundle</span>&gt;</span>mvn:org.opendaylight.hello/hello-impl/&#123;&#123;VERSION&#125;&#125;<span class="tag">&lt;/<span class="name">bundle</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configfile</span> <span class="attr">finalname</span>=<span class="string">"$&#123;configfile.directory&#125;/hello.xml"</span>&gt;</span>mvn:org.opendaylight.hello/hello-impl/&#123;&#123;VERSION&#125;&#125;/xml/config<span class="tag">&lt;/<span class="name">configfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">feature</span>&gt;</span></span><br></pre></td></tr></table></figure><p>마지막으로 singletonsimple 프로젝트의 yang 파일중에 commons.yang , global-rpc.yang 파일을 hello 프로젝트의 api 폴더에 있는 yang 폴더로 옮겨주고</p><p>GlobalRpcServiceImpl.java , HostInformation.java 파일도 impl/src/main/java 하위에 HelloProvider.java 파일이 있는곳에 옮겨주면 singletonsimple 에서 구현된 global-rpc 를 사용 할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;앞선 예제에서 사용했던 hello 프로젝트를 clustering을 이용하도록 구현해보자.&lt;/p&gt;
&lt;p&gt;목표는 global-rpc,routed-rpc 구현과 datastore 공유이다.&lt;/p&gt;
&lt;p&gt;hello 프로젝트에 아무런 설정을 하지 않고&lt;/
      
    
    </summary>
    
      <category term="OpenDayLight" scheme="https://osujin.github.io/categories/OpenDayLight/"/>
    
    
  </entry>
  
  <entry>
    <title>ODL(OpenDayLight) 기본 튜토리얼 #7_2 – ODL Clustering 소스 배포</title>
    <link href="https://osujin.github.io/2017/03/13/ODL(OpenDayLight)-%EA%B8%B0%EB%B3%B8-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-7_2-%E2%80%93-ODL-Clustering-%EC%86%8C%EC%8A%A4-%EB%B0%B0%ED%8F%AC/"/>
    <id>https://osujin.github.io/2017/03/13/ODL(OpenDayLight)-기본-튜토리얼-7_2-–-ODL-Clustering-소스-배포/</id>
    <published>2017-03-13T06:35:22.000Z</published>
    <updated>2018-04-04T05:37:24.254Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 앞서 구축한 3개의 docker instance에 소스를 배포하고 기동하는 방법이다.</p><p>테스트 소스는 coretutorials/clustering 하위에 있는 singletonsimple 으로 하겠다.</p><p>먼저 singletonsimple 을 빌드를 해야 하는데 singletonsimple-impl 를 빌드하다 문제가 발생했었다.</p><ul><li>[ERROR] Failed to execute goal org.apache.maven.plugins:maven-enforcer-plugin:1.4.1:enforce</li></ul><p>위와 같은 에러였는데 singletonsimple-impl/pom.xml 파일에 parent 버전정보를 불러오는 곳이 있는데 기존에 있던 <version>1.8.0-SNAPSHOT</version> 해당 버전이 존재하지 않아 발생한것 같다. 이부분을 Boron 버전중에 하나로 설정해주면 된다. 필자는 0.5.2-Boron-SR2 버전을 사용하였다.</p><p>빌드를 완료했으면 각 instance로 배포를 해야 한다. 문서에 나와 있는 ansible을 이용하여 배포해보도록 하겠다.</p><p>ansible을 이용하기전에 한가지 작업해줄게 있다.</p><ul><li>docker로 띄운 3개의 instance에 /opt/scripts/ 폴더를 생성하고 coretutorials/clustering/node/install_odl.sh, configure-cluster-ipdetect.sh 파일을 복사해주어야 한다.</li></ul><p>ansible 설치 방법은 구글을 참조하길 바란다.</p><ul><li>ansible로 소스 배포하기_ docker-Host $ cd coretutorials/clustering/scripts/ansible docker-Host $ ansible-playbook -i hosts playbook.yaml</li></ul><p>playbook.yaml 파일내용을 약간 수정을 해줘야 하는데 파일을 열어보면</p><ul><li>distro_name: singletonsimple-karaf-0.1.0-SNAPSHOT.zip local_path: /Users/jmedved/Documents/ODL/Git/coretutorials/clustering/singletonsimple/karaf/target</li></ul><p>위 두줄이 있는데 <strong>distro_name</strong> 부분에 자신이 배포하고 싶은 소스명을 적고 <strong>local_path</strong> 부분에 해당 소스가 있는 경로를 적어주면 된다. 배포되는 소스는 zip 으로 압축된것을 보낸다.</p><p>수동으로 배포하는 방법도 알아보자</p><p>singletonsimple을 빌드하면 singletonsimple/karaf/target 하위에 컴파일된 파일들이 있는데 .zip 으로 된 파일을 docker instance 들에게 ftp등을 이용하여 전송하면된다.\</p><p>전송한뒤에는 앞서 옮긴 install_odl.sh 파일을 이용하여 cluster 셋팅을 해주어야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member 1~3 # /opt/scripts/install_odl.sh -d [컴파일된 소스가 저장될 경로] – i [Zip 파일명] -p [Zip 파일 경로] -c [클러스터를 형성할 3개의 instance들의 IP] EX.) &gt; member 1~3 # /opt/scripts/install_odl.sh -d /opt/odl – i example-karaf-0.1.0-SNAPSHOT.zip -p . -c ‘172.17.0.2 172.17.0.3 172.17.0.4’</span><br></pre></td></tr></table></figure><p>configure-cluster-ipdetect.sh 파일을 열어보면 zip/configuration에 initial폴더를 생성하고 akka.conf , module-shards.conf , modules.conf 3개의 파일을 생성하는데 akka.conf 파일에 cluster를 형성할 instance들의 ip 정보가 담겨져 있다.</p><p>ODL Cluster구성은 akka framework를 이용해서 구성을 하는듯 하다.</p><p>akka 설정을 통해 cluster node를 설정할 수 있고 손쉽게 여러개의 cluster node 구현이 가능하다.</p><p><a href="http://docs.opendaylight.org/en/stable-boron/getting-started-guide/common-features/clustering.html" target="_blank" rel="noopener">Multiple Node Clustering 공식 문서</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번에는 앞서 구축한 3개의 docker instance에 소스를 배포하고 기동하는 방법이다.&lt;/p&gt;
&lt;p&gt;테스트 소스는 coretutorials/clustering 하위에 있는 singletonsimple 으로 하겠다.&lt;/p&gt;
&lt;p&gt;먼저 sin
      
    
    </summary>
    
      <category term="OpenDayLight" scheme="https://osujin.github.io/categories/OpenDayLight/"/>
    
    
  </entry>
  
  <entry>
    <title>ODL(OpenDayLight) 기본 튜토리얼 #7_1 – ODL Cluster 환경 구축</title>
    <link href="https://osujin.github.io/2017/03/13/ODL(OpenDayLight)-%EA%B8%B0%EB%B3%B8-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-7_1-%E2%80%93-ODL-Cluster-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95/"/>
    <id>https://osujin.github.io/2017/03/13/ODL(OpenDayLight)-기본-튜토리얼-7_1-–-ODL-Cluster-환경-구축/</id>
    <published>2017-03-13T05:44:04.000Z</published>
    <updated>2018-04-04T05:35:11.645Z</updated>
    
    <content type="html"><![CDATA[<p>3개의 가상 Host를 이용하여 ODL cluster를 테스트 할수 있는 환경 구축해보도록 한다.</p><p>테스트에 사용된 자료는 OpenDayLight Core Tutorials 이다. 다운 받도록 하자.</p><ul><li>git clone <a href="https://git.opendaylight.org/gerrit/coretutorials.git" target="_blank" rel="noopener">https://git.opendaylight.org/gerrit/coretutorials.git</a></li></ul><p>소스를 다운받으면 <strong>clustering</strong> 폴더 안에</p><ul><li>script</li><li>shardingsimple</li><li>singletonhs</li><li>singletonsimple</li><li>src</li></ul><p>위와 같이 3개의 Maven 프로젝트가 있는데 이중 script 폴더는 cluster 환경을 구축하고 소스를 배포하는데 필요한 스크립트와 메뉴얼이 있고 나머지 3개의 폴더는 각각 cluster를 활용한 프로젝트이다.(src 폴더는 무시하도록하자)</p><p>지금부터는 scipts/site/asciidoc 폴더에 있는 scripts-user-manual.adoc 파일을 기반으로 설명하도록 하겠다.</p><p>scripts-user-manual.adoc 파일을 보면 docker를 이용하여 3개의 가상 호스트를 띄우고 ansible을 이용하여 컴파일된 소스를 각각의 호스트에 자동으로 배포하는 방법이 설명되어 있다.</p><p><strong>1. Docker 를 이용하여 3개의 Host 띄우기</strong></p><p>당연한 얘기지만 일단 google 검색을 이용하여 docker를 설치한뒤 다음 명령어들을 입력해줍니다. </p><p>docker image는 ubuntu가 설치 됩니다. 작업할때는 root 로 하였는데 일반계정으로 작업 하고 싶으시면 docker 권한 설정을 하시면 됩니다.</p><p>필수사항 : jre 1.8</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root # cd coretutorials/clustering/scripts/node</span><br><span class="line"> //git 에서 다운받은 소스에 포함도니 docker 생성 파일을 이용하기 위해 </span><br><span class="line">root # docker build -t clustering/odlbase:v1.1 .  </span><br><span class="line"> //docker container 생성 </span><br><span class="line">root # docker images</span><br><span class="line"></span><br><span class="line"> ex.) [root@ODL-Cluster#1 ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE   </span><br><span class="line">      clustering/odlbase v1.1 be2bcc26a885 4 days ago 518 MB </span><br><span class="line">      ubuntu 16.04 0ef2e08ed3fa 13 days ago 130 MB</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo@bar:~$ whoami</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root # docker save -o odl-base.tar clustering/odlbase:v1.1</span><br><span class="line">//container 저장</span><br><span class="line">root # docker load -i odl-base.tar</span><br><span class="line">//위에서 저장한 docker container 가 재대로 생성이 되는지 확인하기 위해</span><br><span class="line">root # docker run -d –name member-1 -h member-1 clustering/odlbase:v1.1</span><br><span class="line">//3개의 인스턴트 실행</span><br><span class="line">root # docker run -d –name member-2 -h member-2 clustering/odlbase:v1.1 # docker run -d –name member-3 -h member-3 clustering/odlbase:v1.1</span><br><span class="line">root # docker ps</span><br><span class="line">// docker instance 실행 확인</span><br></pre></td></tr></table></figure><p>여기까지 문제 없이 했다면 3개의 docker instance가 떠있을것이다.</p><p>각 instance에 접속하는 방법은 ssh <a href="mailto:root@172.17.0.2" target="_blank" rel="noopener">root@172.17.0.2</a> ssh <a href="mailto:root@172.17.0.3" target="_blank" rel="noopener">root@172.17.0.3</a> ssh <a href="mailto:root@172.17.0.4" target="_blank" rel="noopener">root@172.17.0.4</a> 으로 비밀번호는 <strong>docker123</strong> 이다.</p><p>다음으로 ssh인증키 설정이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">인증키 생성 방법</span><br><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">//id_rsa.pub , id_rsa 파일 생성</span><br></pre></td></tr></table></figure><p>docker를 설치한 호스트의 ~/.ssh/authorized_keys에 위에서 실행한 3개의 docker instance의 id_rsa.pub 파일을 복사해준다.</p><ul><li>ssh-copy-id &lt;username&#62;@&lt;host&#62;</li></ul><p>혹은 수동으로 직접 id_rsa.pub 파일을 authorized_keys에 등록해주어도 된다.</p><ul><li>docker host에는 3개 instance 의 id_rsa.pub 파일을 등록해주면 되고 instance 3개에는 docker host의 id_rsa.pub 파일을 등록해주면 된다.</li></ul><p>여기까지 ODL clustering 을 실행 할 수 있는 환경설정이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;3개의 가상 Host를 이용하여 ODL cluster를 테스트 할수 있는 환경 구축해보도록 한다.&lt;/p&gt;
&lt;p&gt;테스트에 사용된 자료는 OpenDayLight Core Tutorials 이다. 다운 받도록 하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git cl
      
    
    </summary>
    
      <category term="OpenDayLight" scheme="https://osujin.github.io/categories/OpenDayLight/"/>
    
    
  </entry>
  
</feed>
